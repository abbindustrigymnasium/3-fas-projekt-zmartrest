import 'package:zmartrest/logic.dart';

void streamWhenReady() async {
  await polar.sdkFeatureReady.firstWhere(
    (e) =>
        e.identifier == identifier &&
        e.feature == PolarSdkFeature.onlineStreaming,
  );
  final availabletypes =
      await polar.getAvailableOnlineStreamDataTypes(identifier);

  debugPrint('Available types: $availabletypes');

  if (availabletypes.contains(PolarDataType.hr)) {
    polar
        .startHrStreaming(identifier)
        .listen((e) => log('Heart rate: ${e.samples.map((e) => e.hr)}'));
  }
  if (availabletypes.contains(PolarDataType.ecg)) {
    polar
        .startEcgStreaming(identifier)
        .listen((e) => log('ECG data received: ${e.samples}'));
  }
  if (availabletypes.contains(PolarDataType.acc)) {
    polar
        .startAccStreaming(identifier)
        .listen((e) => log('Accelerometer data: ${e.samples}'));
  }
  if (availabletypes.contains(PolarDataType.ppg)) {
    polar
        .startPpgStreaming(identifier)
        .listen((e) => log('PPG data received: ${e.samples}'));
  }
  if (availabletypes.contains(PolarDataType.ppi)) {
    polar
        .startPpiStreaming(identifier)
        .listen((e) => log('PPI data received: ${e.samples}'));
  }
  if (availabletypes.contains(PolarDataType.gyro)) {
    polar
        .startGyroStreaming(identifier)
        .listen((e) => log('Gyroscope data: ${e.samples}'));
  }
  if (availabletypes.contains(PolarDataType.mag)) {
    polar
        .startMagStreaming(identifier)
        .listen((e) => log('Magnetometer data: ${e.samples}'));
  }
  if (availabletypes.contains(PolarDataType.temp)) {
    polar
        .startTempStreaming(identifier)
        .listen((e) => log('Temperature data received: ${e.samples}'));
  }
}

void log(String log) {
  debugPrint(log);
  setState(() {
    logs.add(log);
  });
}

Future<void> handleRecordingAction(RecordingAction action) async {
  switch (action) {
    case RecordingAction.start:
      log('Starting recording');
      await polar.startRecording(
        identifier,
        exerciseId: const Uuid().v4(),
        interval: RecordingInterval.interval_1s,
        sampleType: SampleType.rr,
      );
      log('Started recording');
      break;
    case RecordingAction.stop:
      log('Stopping recording');
      await polar.stopRecording(identifier);
      log('Stopped recording');
      break;
    case RecordingAction.status:
      log('Getting recording status');
      final status = await polar.requestRecordingStatus(identifier);
      log('Recording status: $status');
      break;
    case RecordingAction.list:
      log('Listing recordings');
      final entries = await polar.listExercises(identifier);
      log('Recordings: $entries');
      // H10 can only store one recording at a time
      exerciseEntry = entries.first;
      break;
    case RecordingAction.fetch:
      log('Fetching recording');
      if (exerciseEntry == null) {
        log('Exercises not yet listed');
        await handleRecordingAction(RecordingAction.list);
      }
      final entry = await polar.fetchExercise(identifier, exerciseEntry!);
      log('Fetched recording: $entry');
      break;
    case RecordingAction.remove:
      log('Removing recording');
      if (exerciseEntry == null) {
        log('No exercise to remove. Try calling list first.');
        return;
      }
      await polar.removeExercise(identifier, exerciseEntry!);
      log('Removed recording');
      break;
  }
}

enum RecordingAction {
  start,
  stop,
  status,
  list,
  fetch,
  remove,
}
